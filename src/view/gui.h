#ifndef VIEW_GUI_H
#define VIEW_GUI_H

/**
 * @file gui.h
 * @brief Главное представление приложения 3D Viewer
 */

#include <QApplication>
#include <QFileDialog>
#include <QFileInfo>
#include <QMessageBox>
#include <QMouseEvent>
#include <QPoint>
#include <QWheelEvent>
#include <QWidget>
#include <clocale>
#include <functional>

#include "facade.h"
#include "opengl_widget.h"

QT_BEGIN_NAMESPACE
namespace Ui {
class View;
}
QT_END_NAMESPACE

namespace s21 {

class Facade;

/**
 * @brief Структура для хранения состояния трансформаций
 *
 * Содержит текущие значения всех трансформаций объекта,
 * используется для вычисления дельт при изменении слайдеров.
 *
 * @details Все значения инициализируются безопасными начальными состояниями:
 * - Перемещения в нуле
 * - Повороты в нуле
 * - Масштаб равен 1.0 (исходный размер)
 */
struct TransformState {
  double move_x = 0.0;  ///< Смещение по оси X в единицах модели
  double move_y = 0.0;  ///< Смещение по оси Y в единицах модели
  double move_z = 0.0;  ///< Смещение по оси Z в единицах модели
  double rotate_x = 0.0;  ///< Угол поворота вокруг оси X в градусах
  double rotate_y = 0.0;  ///< Угол поворота вокруг оси Y в градусах
  double rotate_z = 0.0;  ///< Угол поворота вокруг оси Z в градусах
  double scale = 1.0;  ///< Коэффициент масштабирования
};

/**
 * @brief Главный класс представления приложения 3D Viewer
 *
 * Класс View является основным представлением в архитектуре MVC приложения.
 * Отвечает за отображение пользовательского интерфейса, обработку
 * пользовательского ввода и передачу команд контроллеру через систему
 * сигналов/слотов Qt.
 *
 * @details Основные возможности:
 * - Загрузка 3D моделей через диалог выбора файла или drag&drop
 * - Интерактивное управление трансформациями через слайдеры
 * - Отображение информации о модели (количество вершин/рёбер)
 * - Применение тёмной темы оформления
 * - Обработка событий мыши для манипуляций с моделью в 3D пространстве
 *
 * Класс реализует паттерн Observer через Qt сигналы/слоты для слабой связности
 * с контроллером и следует принципам SOLID.
 *
 * @example
 * @code
 * View* view = new View();
 * view->show();
 *
 * // Подключение к контроллеру
 * connect(view, &View::SetModel, controller, &Controller::LoadModel);
 * connect(controller, &Controller::ModelLoaded,
 *         view, &View::HandleModelLoaded_);
 * @endcode
 *
 * @see Controller
 * @see OpenGLWidget
 * @see Facade
 */
class View : public QWidget {
  Q_OBJECT

 public:
  /**
   * @brief Конструктор представления
   *
   * Инициализирует пользовательский интерфейс, создаёт OpenGL виджет
   * для отображения 3D моделей, настраивает локаль, применяет стили
   * и подключает обработчики событий.
   *
   * @param parent Родительский виджет для управления памятью Qt
   *
   * @post Интерфейс полностью инициализирован и готов к использованию
   * @post OpenGL виджет встроен в layout
   * @post Применена тёмная тема
   * @post Все сигналы/слоты подключены
   *
   * @see LoadStyles_()
   * @see ConnectSlotSignals_()
   */
  explicit View(QWidget* parent = nullptr);

  /**
   * @brief Деструктор представления
   *
   * Корректно освобождает память, выделенную для UI элементов
   * и facade объекта.
   */
  ~View();

  Facade* facade;  ///< Указатель на фасад для упрощения доступа к UI

 public slots:
  /**
   * @brief Обработчик успешной загрузки модели
   *
   * Вызывается контроллером при успешном парсинге OBJ файла.
   * Обновляет данные для OpenGL виджета, информацию в UI и
   * сбрасывает состояние слайдеров.
   *
   * @param vertex_index Вектор индексов вершин для рёбер
   * @param vertex_coord Вектор координат вершин (x,y,z последовательно)
   * @param filename Имя загруженного файла для отображения
   * @param vertex_count Количество вершин в модели
   * @param edge_count Количество рёбер в модели
   *
   * @pre Векторы должны содержать валидные данные модели
   * @post OpenGL виджет получил новые данные для отрисовки
   * @post UI обновлён с информацией о модели
   * @post Слайдеры сброшены в исходное положение
   *
   * @see ClearSliders_()
   */
  void HandleModelLoaded_(const std::vector<int>& vertex_index,
                          const std::vector<double>& vertex_coord,
                          const QString& filename, int vertex_count,
                          int edge_count);

  /**
   * @brief Обработчик ошибки загрузки модели
   *
   * Отображает пользователю диалоговое окно с описанием ошибки,
   * возникшей при загрузке или парсинге OBJ файла.
   *
   * @param error_message Локализованное сообщение об ошибке
   *
   * @post Пользователь уведомлён об ошибке через QMessageBox
   */
  void HandleModelLoadError_(const QString& error_message);

  /**
   * @brief Обработчик завершения трансформации модели
   *
   * Вызывается контроллером после успешного применения любой
   * трансформации к модели. Обновляет данные в OpenGL виджете
   * для отображения изменённой модели.
   *
   * @param vertex_index Обновлённый вектор индексов вершин
   * @param vertex_coord Обновлённый вектор координат вершин после трансформации
   *
   * @pre Трансформация успешно применена к модели
   * @post OpenGL виджет отображает обновлённую модель
   */
  void HandleModelTransformed_(const std::vector<int>& vertex_index,
                               const std::vector<double>& vertex_coord);

 protected:
  /**
   * @brief Обработчик движения мыши
   *
   * Перенаправляет события движения мыши в OpenGL виджет
   * для обработки интерактивных манипуляций с моделью.
   *
   * @param event Событие движения мыши
   *
   * @post Событие передано OpenGL виджету для обработки
   */
  void mouseMoveEvent(QMouseEvent* event) override;

  /**
   * @brief Обработчик нажатия кнопки мыши
   *
   * Перенаправляет события нажатия кнопок мыши в OpenGL виджет
   * для начала интерактивных операций (например, начало вращения).
   *
   * @param event Событие нажатия кнопки мыши
   *
   * @post Событие передано OpenGL виджету для обработки
   */
  void mousePressEvent(QMouseEvent* event) override;

  /**
   * @brief Обработчик отпускания кнопки мыши
   *
   * Перенаправляет события отпускания кнопок мыши в OpenGL виджет
   * для завершения интерактивных операций.
   *
   * @param event Событие отпускания кнопки мыши
   *
   * @post Событие передано OpenGL виджету для обработки
   */
  void mouseReleaseEvent(QMouseEvent* event) override;

  /**
   * @brief Обработчик событий колёсика мыши
   *
   * Перенаправляет события прокрутки колёсика мыши в OpenGL виджет
   * для интерактивного масштабирования модели.
   *
   * @param event Событие прокрутки колёсика мыши
   *
   * @post Событие передано OpenGL виджету для обработки
   */
  void wheelEvent(QWheelEvent* event) override;

 signals:
  /**
   * @brief Сигнал запроса загрузки модели
   *
   * Испускается при выборе пользователем файла через диалог
   * или drag&drop операцию. Содержит путь к выбранному файлу.
   *
   * @param file_path Полный путь к OBJ файлу для загрузки
   *
   * @emit Контроллер получает запрос на загрузку модели
   */
  void SetModel(const QString& file_path);

  /**
   * @brief Сигнал запроса трансформации модели
   *
   * Испускается при изменении пользователем значений слайдеров
   * трансформации. Содержит тип трансформации, значение и ось.
   *
   * @param strategy_type Тип трансформации:
   *   - 0 (kMove) - перемещение
   *   - 1 (kRotate) - поворот
   *   - 2 (kScale) - масштабирование
   * @param value Значение трансформации (дельта/угол/коэффициент)
   * @param axis Ось трансформации:
   *   - 0 (kX) - ось X
   *   - 1 (kY) - ось Y
   *   - 2 (kZ) - ось Z
   *
   * @emit Контроллер получает запрос на применение трансформации
   */
  void TransformRequested(int strategy_type, double value, int axis);

 private:
  /**
   * @brief Создаёт обработчик для слайдеров трансформации
   */
  std::function<void(int)> CreateSliderHandler_(int transform_type, int axis,
                                                double scale_factor,
                                                double& state_ref);

  /**
   * @brief Подключает обработчики сигналов/слотов
   *
   * Связывает элементы управления UI (кнопки, слайдеры) с соответствующими
   * обработчиками и настраивает взаимодействие с OpenGL виджетом.
   *
   * @details Подключает:
   * - Кнопку выбора файла к диалогу загрузки
   * - Слайдеры трансформации к вычислению дельт и эмиссии сигналов
   * - Drag&drop события от OpenGL виджета
   *
   * @post Все UI элементы подключены к обработчикам
   * @post Система сигналов/слотов полностью настроена
   */
  void ConnectSlotSignals_();

  /**
   * @brief Сбрасывает слайдеры в исходное положение
   *
   * Устанавливает все слайдеры трансформации в нулевые/дефолтные
   * позиции и сбрасывает внутреннее состояние трансформаций.
   * Вызывается при загрузке новой модели.
   *
   * @post Все слайдеры в исходном положении
   * @post transform_state_ сброшен в начальные значения
   */
  void ClearSliders_();

  /**
   * @brief Загружает таблицы стилей для тёмной темы
   *
   * Читает QSS файл из ресурсов приложения и применяет
   * стили для создания современного тёмного интерфейса.
   *
   * @post Применена тёмная тема оформления
   * @post Все UI элементы стилизованы согласно дизайну
   *
   * @see style.qss
   */
  void LoadStyles_();

  Ui::View* ui_;  ///< Указатель на сгенерированный Qt UI объект
  OpenGLWidget* opengl_widget_;  ///< Виджет для отображения 3D моделей

  // OpenGL data - данные модели для отображения
  int* vertex_index_ = nullptr;  ///< Указатель на массив индексов вершин рёбер
  double* vertex_coord_ = nullptr;  ///< Указатель на массив координат вершин
  int count_vertex_index_ = 0;  ///< Количество элементов в массиве индексов
  int count_vertex_coord_ = 0;  ///< Количество элементов в массиве координат

  // Поля для обработки событий мыши (унаследовано от предыдущих версий)
  QPoint click_pos_;  ///< Позиция клика мыши для вычисления дельт
  bool left_btn_pressed_ = false;  ///< Флаг состояния левой кнопки мыши
  bool right_btn_pressed = false;  ///< Флаг состояния правой кнопки мыши

  TransformState transform_state_;  ///< Текущее состояние всех трансформаций
};

}  // namespace s21

#endif  // VIEW_GUI_H
